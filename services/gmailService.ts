import { supabase } from './supabaseClient';
import { getAppSetting } from './supabaseService';

let gisLoaded = false;
let tokenClient: any = null;
let cachedAccessToken: string | null = null;

async function getGoogleClientId(): Promise<string> {
  // 1) Tentar buscar do Supabase primeiro
  try {
    const v = await getAppSetting('GOOGLE_OAUTH_CLIENT_ID');
    if (typeof v === 'string' && v.trim()) {
      console.log('‚úÖ GMAIL - Client ID obtido do Supabase');
      return v.trim();
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è GMAIL - Erro ao buscar Client ID do Supabase:', error);
  }

  // 2) Tentar buscar de configura√ß√£o local/global
  const local: any = (globalThis as any).APP_CONFIG_LOCAL;
  const localId = local?.GOOGLE_OAUTH_CLIENT_ID;
  if (localId && typeof localId === 'string' && localId.trim()) {
    console.log('‚úÖ GMAIL - Client ID obtido de configura√ß√£o local');
    return localId.trim();
  }

  // 3) Tentar buscar de vari√°veis de ambiente (Vite)
  const envId = import.meta.env?.VITE_GMAIL_CLIENT_ID;
  if (envId && typeof envId === 'string' && envId.trim()) {
    console.log('‚úÖ GMAIL - Client ID obtido de vari√°vel de ambiente');
    return envId.trim();
  }

  // 4) Fallback para Client ID hardcoded (apenas para produ√ß√£o espec√≠fica)
  const isProduction = window.location.hostname === 'app.grupoggv.com';
  if (isProduction) {
    // üö® ATEN√á√ÉO: Este Client ID deve estar configurado no Google Cloud Console
    // para o dom√≠nio app.grupoggv.com com scopes gmail.send e gmail.compose
    const productionClientId = '1048970542386-8u3v6p7c2s8l5q9k1m0n2b4x7y6z3a5w.apps.googleusercontent.com';
    console.log('üîß GMAIL - Usando Client ID de produ√ß√£o (fallback)');
    console.log('‚ö†Ô∏è GMAIL - IMPORTANTE: Verificar se este Client ID est√° configurado corretamente no Google Console');
    console.log('üîó GMAIL - Console: https://console.cloud.google.com/apis/credentials');
    return productionClientId;
  }

  console.error('‚ùå GMAIL - Nenhuma configura√ß√£o de Client ID encontrada');
  throw new Error('GOOGLE_OAUTH_CLIENT_ID n√£o configurado. Verifique as configura√ß√µes do Supabase ou vari√°veis de ambiente.');
}

async function ensureGis(): Promise<void> {
  if (gisLoaded) return;
  
  // Verificar se j√° existe globalmente
  if ((window as any).google?.accounts?.oauth2) {
    console.log('‚úÖ GMAIL - Google Identity Services j√° dispon√≠vel');
    gisLoaded = true;
    return;
  }
  
  console.log('üîÑ GMAIL - Carregando Google Identity Services...');
  
  // Remover scripts antigos que podem estar corrompidos
  const existingScripts = document.querySelectorAll('script[src*="gsi/client"]');
  existingScripts.forEach(script => {
    console.log('üßπ GMAIL - Removendo script antigo');
    script.remove();
  });
  
  await new Promise<void>((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://accounts.google.com/gsi/client';
    script.async = false; // Carregar de forma s√≠ncrona para evitar problemas
    script.defer = false;
    
    let resolved = false;
    
    const cleanup = () => {
      if (resolved) return;
      resolved = true;
    };
    
    const checkGoogle = () => {
      if ((window as any).google?.accounts?.oauth2) {
        cleanup();
        console.log('‚úÖ GMAIL - Google Identity Services carregado com sucesso');
        resolve();
        return true;
      }
      return false;
    };
    
    // Timeout mais longo para dar tempo ao script carregar
    const timeout = setTimeout(() => {
      if (resolved) return;
      console.error('‚è∞ GMAIL - Timeout ao carregar Google Identity Services');
      
      // Verificar uma √∫ltima vez se carregou
      if (!checkGoogle()) {
        cleanup();
        reject(new Error('Timeout ao carregar Google Identity Services ap√≥s 20 segundos'));
      }
    }, 20000);
    
    script.onload = () => {
      console.log('üì¶ GMAIL - Script carregado, aguardando inicializa√ß√£o...');
      
      // Aguardar inicializa√ß√£o com polling
      let attempts = 0;
      const maxAttempts = 50; // 5 segundos total
      
      const pollForGoogle = () => {
        attempts++;
        
        if (checkGoogle()) {
          clearTimeout(timeout);
          return;
        }
        
        if (attempts < maxAttempts) {
          setTimeout(pollForGoogle, 100);
        } else {
          cleanup();
          clearTimeout(timeout);
          console.error('‚ùå GMAIL - Google n√£o inicializou ap√≥s carregamento do script');
          reject(new Error('Google Identity Services n√£o inicializou ap√≥s carregamento'));
        }
      };
      
      setTimeout(pollForGoogle, 100);
    };
    
    script.onerror = (error) => {
      cleanup();
      clearTimeout(timeout);
      console.error('‚ùå GMAIL - Erro ao carregar script:', error);
      reject(new Error('Falha ao carregar script do Google Identity Services'));
    };
    
    try {
      document.head.appendChild(script);
      console.log('üì¶ GMAIL - Script adicionado ao DOM');
    } catch (error) {
      cleanup();
      clearTimeout(timeout);
      console.error('‚ùå GMAIL - Erro ao adicionar script ao DOM:', error);
      reject(new Error('Erro ao adicionar script ao DOM'));
    }
  });
  
  gisLoaded = true;
}



function base64UrlEncode(input: string): string {
  // btoa lida com ASCII; para UTF-8 usamos TextEncoder
  const bytes = new TextEncoder().encode(input);
  let binary = '';
  bytes.forEach((b) => (binary += String.fromCharCode(b)));
  const base64 = btoa(binary);
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

function base64Encode(input: string): string {
  const bytes = new TextEncoder().encode(input);
  let binary = '';
  bytes.forEach((b) => (binary += String.fromCharCode(b)));
  return btoa(binary);
}

function buildMime({ to, subject, html, fromName, fromEmail }: { to: string; subject: string; html: string; fromName?: string; fromEmail?: string; }): string {
  // Encode subject for UTF-8 per RFC 2047
  const encodedSubject = `=?UTF-8?B?${base64Encode(subject)}?=`;
  const headers = [
    fromEmail ? `From: ${fromName ? `${fromName} <${fromEmail}>` : fromEmail}` : undefined,
    `To: ${to}`,
    `Subject: ${encodedSubject}`,
    'MIME-Version: 1.0',
    'Content-Type: text/html; charset="UTF-8"',
  ].filter(Boolean);
  const raw = `${headers.join('\r\n')}\r\n\r\n${html}`;
  return base64UrlEncode(raw);
}

// Cache persistente de tokens
const TOKEN_CACHE_KEY = 'ggv_gmail_token_cache';
const TOKEN_EXPIRY_BUFFER = 5 * 60 * 1000; // 5 minutos de buffer
const SUPABASE_SESSION_DURATION = 100 * 60 * 60 * 1000; // 100 horas em ms

interface TokenCache {
  access_token: string;
  expires_at: number;
  scope?: string;
  refresh_token?: string;
  source: 'supabase' | 'oauth' | 'manual';
  session_id?: string;
}

function saveTokenToCache(token: string, expiresIn: number = 3600, source: 'supabase' | 'oauth' | 'manual' = 'oauth', sessionId?: string): void {
  try {
    const cache: TokenCache = {
      access_token: token,
      expires_at: Date.now() + (expiresIn * 1000) - TOKEN_EXPIRY_BUFFER,
      scope: 'gmail.send gmail.compose',
      source,
      session_id: sessionId
    };
    localStorage.setItem(TOKEN_CACHE_KEY, JSON.stringify(cache));
    console.log(`üíæ GMAIL - Token salvo no cache (${source}, v√°lido por ${Math.round(expiresIn/3600)}h)`);
  } catch (error) {
    console.warn('‚ö†Ô∏è GMAIL - Erro ao salvar token no cache:', error);
  }
}

async function getTokenFromCache(): Promise<string | null> {
  try {
    const cacheStr = localStorage.getItem(TOKEN_CACHE_KEY);
    if (!cacheStr) return null;
    
    const cache: TokenCache = JSON.parse(cacheStr);
    
    // Se o token √© do Supabase, verificar se a sess√£o ainda √© v√°lida
    if (cache.source === 'supabase' && cache.session_id) {
      try {
        const { data: { session } } = await supabase.auth.getSession();
        if (!session || session.user.id !== cache.session_id) {
          console.log('üîÑ GMAIL - Sess√£o do Supabase mudou, removendo token antigo...');
          localStorage.removeItem(TOKEN_CACHE_KEY);
          return null;
        }
        // Se sess√£o √© v√°lida, token do Supabase √© v√°lido independente do tempo
        console.log('üíæ GMAIL - Token do Supabase v√°lido (baseado na sess√£o ativa)');
        return cache.access_token;
      } catch (error) {
        console.warn('‚ö†Ô∏è GMAIL - Erro ao verificar sess√£o do Supabase:', error);
      }
    }
    
    // Para tokens OAuth tempor√°rios, verificar expira√ß√£o normal
    if (Date.now() < cache.expires_at) {
      console.log(`üíæ GMAIL - Token ${cache.source} v√°lido encontrado no cache`);
      return cache.access_token;
    } else {
      console.log(`‚è∞ GMAIL - Token ${cache.source} no cache expirou, removendo...`);
      localStorage.removeItem(TOKEN_CACHE_KEY);
      return null;
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è GMAIL - Erro ao ler token do cache:', error);
    localStorage.removeItem(TOKEN_CACHE_KEY);
    return null;
  }
}

async function clearCachedTokens(): Promise<void> {
  cachedAccessToken = null;
  tokenClient = null;
  
  // Limpar cache persistente
  try {
    localStorage.removeItem(TOKEN_CACHE_KEY);
    localStorage.removeItem('gmail_access_token');
    sessionStorage.removeItem('gmail_access_token');
  } catch {}
  
  console.log('üßπ GMAIL - Tokens cacheados limpos');
}

async function getAccessToken(): Promise<string> {
  // 1) Verificar cache em mem√≥ria primeiro
  if (cachedAccessToken) {
    console.log('üîÑ GMAIL - Usando token da mem√≥ria');
    return cachedAccessToken;
  }
  
  // 2) Verificar cache persistente
  const cachedToken = await getTokenFromCache();
  if (cachedToken) {
    cachedAccessToken = cachedToken;
    return cachedToken;
  }
  
  // 3) PRIORIDADE: Token do Supabase (v√°lido enquanto usu√°rio estiver logado - 100h)
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (session && session.user) {
      console.log('üîç GMAIL - Verificando sess√£o do Supabase:', {
        provider: session.user.app_metadata?.provider,
        hasProviderToken: !!(session as any).provider_token,
        hasProviderAccessToken: !!(session as any).provider_access_token,
        hasAccessToken: !!(session as any).access_token
      });
      
      const anySess: any = session as any;
      // Tentar m√∫ltiplos campos onde o token pode estar
      const prov = (anySess?.provider_token as string) || 
                   (anySess?.provider_access_token as string) || 
                   (session?.access_token as string) ||
                   null;
      
      if (prov && session.user.app_metadata?.provider === 'google') {
        console.log('‚úÖ GMAIL - Token do Supabase OAuth encontrado (v√°lido por 100h)');
        console.log('üîë GMAIL - Tipo de token encontrado:', prov.substring(0, 20) + '...');
        cachedAccessToken = prov;
        
        // Salvar no cache com dura√ß√£o da sess√£o do Supabase (100h)
        const sessionDurationHours = 100;
        const sessionDurationSeconds = sessionDurationHours * 60 * 60;
        saveTokenToCache(prov, sessionDurationSeconds, 'supabase', session.user.id);
        
        return prov;
      } else if (session.user.app_metadata?.provider !== 'google') {
        console.log('‚ÑπÔ∏è GMAIL - Usu√°rio n√£o logou com Google, ser√° necess√°rio OAuth separado');
      } else if (session.user.app_metadata?.provider === 'google' && !prov) {
        console.log('‚ö†Ô∏è GMAIL - Login com Google detectado, mas token n√£o encontrado na sess√£o');
        console.log('üìã GMAIL - Campos da sess√£o dispon√≠veis:', Object.keys(session));
      }
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è GMAIL - Erro ao obter token do Supabase:', error);
  }

  await ensureGis();
  const clientId = await getGoogleClientId();
  
  // Escopo mais espec√≠fico para envio de e-mail
  const scopes = 'https://www.googleapis.com/auth/gmail.send https://www.googleapis.com/auth/gmail.compose';
  
  const google: any = (window as any).google;
  if (!google?.accounts?.oauth2) throw new Error('Google Identity Services indispon√≠vel');
  
  if (!tokenClient) {
    tokenClient = google.accounts.oauth2.initTokenClient({ 
      client_id: clientId, 
      scope: scopes, 
      prompt: 'consent', // Sempre pedir consentimento para garantir permiss√µes
      callback: () => {} 
    });
  }

  const tryRequest = (promptMode: '' | 'consent'): Promise<string> => new Promise((resolve, reject) => {
    let finished = false;
    const timeout = window.setTimeout(() => {
      if (!finished) {
        finished = true;
        reject(new Error('Timeout ao obter token do Google'));
      }
    }, 15000); // Aumentado para 15 segundos
    
    tokenClient.callback = (resp: any) => {
      if (finished) return;
      window.clearTimeout(timeout);
      finished = true;
      if (resp?.access_token) return resolve(resp.access_token);
      reject(new Error(resp?.error || 'Falha ao obter token do Google'));
    };
    
    try { 
      tokenClient.requestAccessToken({ prompt: promptMode }); 
    } catch (e) { 
      window.clearTimeout(timeout); 
      reject(e); 
    }
  });

  // Sempre tentar com consentimento primeiro para garantir permiss√µes
  let token: string;
  try {
    token = await tryRequest('consent');
  } catch (error) {
    console.warn('‚ö†Ô∏è GMAIL - Falha com consent, tentando sem:', error);
    try {
      token = await tryRequest('');
    } catch (secondError) {
      console.error('‚ùå GMAIL - Falha em ambas as tentativas:', secondError);
      throw new Error('N√£o foi poss√≠vel obter autoriza√ß√£o do Google. Verifique se os pop-ups est√£o habilitados e tente novamente.');
    }
  }
  
  cachedAccessToken = token;
  // Salvar token OAuth tempor√°rio no cache (1 hora)
  saveTokenToCache(token, 3600, 'oauth');
  console.log('‚úÖ GMAIL - Token OAuth tempor√°rio obtido e salvo no cache (1h)');
  return token;
}

async function testGmailPermissions(token: string): Promise<boolean> {
  try {
    const res = await fetch('https://gmail.googleapis.com/gmail/v1/users/me/profile', {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    return res.ok;
  } catch {
    return false;
  }
}

export async function sendEmailViaGmail({ to, subject, html }: { to: string; subject: string; html: string; }): Promise<boolean> {
  let retryCount = 0;
  const maxRetries = 3; // Aumentando para 3 tentativas
  
  console.log('üìß GMAIL - Iniciando processo de envio de e-mail...', {
    destinatario: to,
    assunto: subject.substring(0, 50) + '...',
    tamanhoHtml: html.length,
    timestamp: new Date().toISOString()
  });
  
  while (retryCount <= maxRetries) {
    try {
      console.log(`üìß GMAIL - Tentativa ${retryCount + 1} de ${maxRetries + 1}...`);
      
      // Verificar configura√ß√£o do Client ID antes de tentar obter token
      try {
        const clientId = await getGoogleClientId();
        console.log('‚úÖ GMAIL - Client ID configurado:', clientId.substring(0, 20) + '...');
      } catch (configError) {
        console.error('‚ùå GMAIL - Erro de configura√ß√£o:', configError);
        throw new Error(`Configura√ß√£o Gmail inv√°lida: ${configError instanceof Error ? configError.message : 'Erro desconhecido'}`);
      }
      
      const token = await getAccessToken();
      console.log('‚úÖ GMAIL - Token obtido:', token.substring(0, 20) + '...');
      
      // Testar permiss√µes antes de tentar enviar
      console.log('üîç GMAIL - Testando permiss√µes...');
      const hasPermissions = await testGmailPermissions(token);
      if (!hasPermissions) {
        console.log('‚ö†Ô∏è GMAIL - Token inv√°lido ou permiss√µes insuficientes');
        
        // Verificar se era um token do Supabase
        const cacheStr = localStorage.getItem(TOKEN_CACHE_KEY);
        let wasSupabaseToken = false;
        if (cacheStr) {
          try {
            const cache: TokenCache = JSON.parse(cacheStr);
            wasSupabaseToken = cache.source === 'supabase';
            console.log('üìã GMAIL - Tipo de token no cache:', cache.source);
          } catch {}
        }
        
        // Limpar cache em mem√≥ria
        cachedAccessToken = null;
        
        if (wasSupabaseToken) {
          console.log('üîÑ GMAIL - Token do Supabase inv√°lido, tentando obter novo...');
          // Para tokens do Supabase, limpar cache e tentar obter novo token da sess√£o
          localStorage.removeItem(TOKEN_CACHE_KEY);
        } else {
          console.log('üîÑ GMAIL - Token OAuth tempor√°rio inv√°lido, tentando reautenticar...');
        }
        
        retryCount++;
        continue;
      }
      
      console.log('‚úÖ GMAIL - Permiss√µes validadas com sucesso');
      
      // Dados do usu√°rio para From (opcional)
      let fromName: string | undefined = undefined;
      let fromEmail: string | undefined = undefined;
      try {
        const { data: { session } } = await supabase.auth.getSession();
        fromEmail = session?.user?.email || undefined;
        const md: any = session?.user?.user_metadata || {};
        fromName = md.full_name || md.name || undefined;
      } catch {}

      const raw = buildMime({ to, subject, html, fromName, fromEmail });
      
      console.log('üìß GMAIL - Enviando e-mail...');
      
      const res = await fetch('https://gmail.googleapis.com/gmail/v1/users/me/messages/send', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ raw }),
      });
      
      console.log('üìß GMAIL - Resposta da API:', {
        status: res.status,
        statusText: res.statusText,
        ok: res.ok,
        destinatario: to
      });
      
      if (!res.ok) {
        let details = '';
        let errorData = null;
        try { 
          errorData = await res.json(); 
          details = errorData?.error?.message || JSON.stringify(errorData); 
          console.log('‚ùå GMAIL - Detalhes do erro completo:', errorData);
        } catch (parseError) {
          console.warn('‚ö†Ô∏è GMAIL - Erro ao fazer parse da resposta de erro:', parseError);
        }
        
        // Diagn√≥stico espec√≠fico para erro 401
        if (res.status === 401) {
          console.log('üö® GMAIL - ERRO 401 UNAUTHORIZED - Diagn√≥stico detalhado:');
          console.log('üîç GMAIL - Status da sess√£o do usu√°rio:');
          
          try {
            const { data: { session } } = await supabase.auth.getSession();
            console.log('üìã GMAIL - Sess√£o ativa:', !!session);
            console.log('üìã GMAIL - Provider:', session?.user?.app_metadata?.provider);
            console.log('üìã GMAIL - User ID:', session?.user?.id?.substring(0, 8) + '...');
            console.log('üìã GMAIL - Email:', session?.user?.email);
            
            // Verificar se h√° tokens na sess√£o
            const sessionAny: any = session;
            const hasProviderToken = !!(sessionAny?.provider_token || sessionAny?.provider_access_token);
            console.log('üìã GMAIL - Tem token de provider:', hasProviderToken);
            
          } catch (sessionError) {
            console.error('‚ùå GMAIL - Erro ao verificar sess√£o:', sessionError);
          }
          
          console.log('üîß GMAIL - Tentando limpar tokens e reautenticar...');
          await clearCachedTokens();
          retryCount++;
          continue;
        }
        
        // Se for erro de permiss√£o (403), tentar reautenticar
        if (res.status === 403 && (details.includes('insufficient authentication scopes') || details.includes('insufficient permissions'))) {
          console.log('üîÑ GMAIL - Erro de permiss√£o 403, tentando reautenticar...');
          await clearCachedTokens();
          retryCount++;
          continue;
        }
        
        // Para outros erros de autoriza√ß√£o, tamb√©m tentar reautenticar
        if ([401, 403].includes(res.status)) {
          console.log(`üîÑ GMAIL - Erro de autoriza√ß√£o ${res.status}, tentando reautenticar...`);
          await clearCachedTokens();
          retryCount++;
          continue;
        }
        
        throw new Error(`Gmail API falhou: ${res.status} ${res.statusText}${details ? ' - ' + details : ''}`);
      }
      
      // Obter detalhes da resposta de sucesso
      let responseData = null;
      try {
        responseData = await res.json();
        console.log('‚úÖ GMAIL - Resposta de sucesso completa:', responseData);
        console.log('üìß GMAIL - Message ID:', responseData?.id);
        console.log('üìß GMAIL - Thread ID:', responseData?.threadId);
      } catch (e) {
        console.warn('‚ö†Ô∏è GMAIL - N√£o foi poss√≠vel ler resposta JSON:', e);
      }
      
      console.log('‚úÖ GMAIL - E-mail enviado com sucesso para:', to);
      return true;
      
    } catch (error) {
      console.error(`‚ùå GMAIL - Erro na tentativa ${retryCount + 1}:`, error);
      
      if (retryCount >= maxRetries) {
        // Executar diagn√≥stico completo antes de falhar
        console.log('ü©∫ GMAIL - Executando diagn√≥stico final...');
        try {
          await diagnoseGmailIssue();
        } catch (diagError) {
          console.warn('‚ö†Ô∏è GMAIL - Erro no diagn√≥stico:', diagError);
        }
        
        // Se for erro de permiss√£o, fornecer instru√ß√µes espec√≠ficas
        if (error instanceof Error && (error.message.includes('insufficient authentication scopes') || error.message.includes('insufficient permissions'))) {
          throw new Error('üîê Gmail API: Permiss√µes insuficientes. Clique no bot√£o "Reautenticar" abaixo ou fa√ßa logout e login novamente para conceder permiss√µes de envio de e-mail.');
        }
        
        // Se for erro de configura√ß√£o
        if (error instanceof Error && error.message.includes('GOOGLE_OAUTH_CLIENT_ID')) {
          throw new Error('‚öôÔ∏è Gmail API: Configura√ß√£o n√£o encontrada. Entre em contato com o suporte t√©cnico.');
        }
        
        // Se for erro de rede/timeout
        if (error instanceof Error && (error.message.includes('fetch') || error.message.includes('network') || error.message.includes('timeout'))) {
          throw new Error('üåê Gmail API: Problema de conex√£o. Verifique sua internet e tente novamente.');
        }
        
        // Erro gen√©rico mais informativo
        const errorMsg = error instanceof Error ? error.message : 'Erro desconhecido';
        throw new Error(`üìß Gmail API: N√£o foi poss√≠vel enviar o e-mail ap√≥s 3 tentativas. Erro: ${errorMsg}. Tente reautenticar clicando no bot√£o abaixo.`);
      }
      
      // Limpar tokens e tentar novamente
      await clearCachedTokens();
      retryCount++;
    }
  }
  
  // Este ponto nunca deveria ser alcan√ßado, mas mantemos como fallback
  throw new Error('üìß Gmail API: Sistema de retry falhou. Tente reautenticar ou entre em contato com o suporte.');
}



// Fun√ß√£o para for√ßar reautentica√ß√£o
export async function forceGmailReauth(): Promise<void> {
  console.log('üîÑ GMAIL - Iniciando reautentica√ß√£o OAuth for√ßada...');
  
  // Limpar cache
  await clearCachedTokens();
  
  try {
    // For√ßar novo OAuth com scopes corretos
    const clientId = await getGoogleClientId();
    await ensureGis();
    
    return new Promise((resolve, reject) => {
      tokenClient = (window as any).google.accounts.oauth2.initTokenClient({
        client_id: clientId,
        scope: 'https://www.googleapis.com/auth/gmail.send https://www.googleapis.com/auth/gmail.compose',
        prompt: 'consent', // For√ßa tela de consentimento
        callback: (response: any) => {
          if (response.access_token) {
            console.log('‚úÖ GMAIL - Novo token OAuth obtido com sucesso');
            cachedAccessToken = response.access_token;
            saveTokenToCache(response.access_token, 3600, 'oauth');
            resolve();
          } else {
            console.error('‚ùå GMAIL - Falha na reautentica√ß√£o OAuth:', response);
            reject(new Error('Falha na reautentica√ß√£o OAuth'));
          }
        },
        error_callback: (error: any) => {
          console.error('‚ùå GMAIL - Erro na reautentica√ß√£o OAuth:', error);
          reject(new Error(`Erro OAuth: ${error.type || 'desconhecido'}`));
        }
      });
      
      console.log('üöÄ GMAIL - Solicitando token OAuth...');
      tokenClient.requestAccessToken();
    });
    
  } catch (error) {
    console.error('‚ùå GMAIL - Erro na configura√ß√£o da reautentica√ß√£o:', error);
    throw error;
  }
}

// Fun√ß√£o para verificar se o Gmail est√° configurado
export async function checkGmailSetup(): Promise<{ configured: boolean; error?: string; details?: any }> {
  try {
    console.log('üîç GMAIL - Verificando configura√ß√£o completa...');
    
    const clientId = await getGoogleClientId();
    console.log('‚úÖ GMAIL - Client ID encontrado:', clientId.substring(0, 20) + '...');
    
    // Verificar se o Google Identity Services pode ser carregado
    await ensureGis();
    console.log('‚úÖ GMAIL - Google Identity Services carregado');
    
    // Verificar sess√£o do usu√°rio
    const { data: { session } } = await supabase.auth.getSession();
    const isGoogleUser = session?.user?.app_metadata?.provider === 'google';
    
    const details = {
      clientId: clientId.substring(0, 20) + '...',
      gisLoaded: true,
      hasSession: !!session,
      isGoogleUser,
      userEmail: session?.user?.email,
      hostname: window.location.hostname,
      isProduction: window.location.hostname === 'app.grupoggv.com'
    };
    
    console.log('üìã GMAIL - Configura√ß√£o detalhada:', details);
    
    return { configured: true, details };
  } catch (error) {
    console.error('‚ùå GMAIL - Erro na verifica√ß√£o de configura√ß√£o:', error);
    return { 
      configured: false, 
      error: error instanceof Error ? error.message : 'Erro desconhecido',
      details: {
        hostname: window.location.hostname,
        isProduction: window.location.hostname === 'app.grupoggv.com'
      }
    };
  }
}

// Fun√ß√£o para diagn√≥stico completo do Gmail
export async function diagnoseGmailIssue(): Promise<void> {
  console.log('ü©∫ GMAIL - DIAGN√ìSTICO COMPLETO INICIADO');
  console.log('=' .repeat(50));
  
  // 1. Verificar configura√ß√£o
  console.log('1Ô∏è‚É£ VERIFICANDO CONFIGURA√á√ÉO...');
  const setup = await checkGmailSetup();
  console.log('Configura√ß√£o:', setup);
  
  // 2. Verificar sess√£o do usu√°rio
  console.log('2Ô∏è‚É£ VERIFICANDO SESS√ÉO...');
  try {
    const { data: { session } } = await supabase.auth.getSession();
    console.log('Sess√£o ativa:', !!session);
    if (session) {
      console.log('Provider:', session.user?.app_metadata?.provider);
      console.log('Email:', session.user?.email);
      console.log('User ID:', session.user?.id?.substring(0, 8) + '...');
      
      // Verificar tokens na sess√£o
      const sessionAny: any = session;
      const providerToken = sessionAny?.provider_token || sessionAny?.provider_access_token;
      console.log('Tem provider token:', !!providerToken);
      if (providerToken) {
        console.log('Provider token (in√≠cio):', providerToken.substring(0, 20) + '...');
      }
    }
  } catch (error) {
    console.error('Erro ao verificar sess√£o:', error);
  }
  
  // 3. Verificar cache de tokens
  console.log('3Ô∏è‚É£ VERIFICANDO CACHE...');
  const cachedToken = await getTokenFromCache();
  console.log('Token em cache:', !!cachedToken);
  if (cachedToken) {
    console.log('Token cache (in√≠cio):', cachedToken.substring(0, 20) + '...');
  }
  
  // 4. Testar obten√ß√£o de token
  console.log('4Ô∏è‚É£ TESTANDO OBTEN√á√ÉO DE TOKEN...');
  try {
    const token = await getAccessToken();
    console.log('‚úÖ Token obtido com sucesso:', token.substring(0, 20) + '...');
    
    // 5. Testar permiss√µes
    console.log('5Ô∏è‚É£ TESTANDO PERMISS√ïES...');
    const hasPermissions = await testGmailPermissions(token);
    console.log('Permiss√µes v√°lidas:', hasPermissions);
    
  } catch (error) {
    console.error('‚ùå Erro ao obter token:', error);
  }
  
  console.log('=' .repeat(50));
  console.log('ü©∫ GMAIL - DIAGN√ìSTICO COMPLETO FINALIZADO');
}



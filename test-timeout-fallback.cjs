#!/usr/bin/env node

/**
 * üïê TESTE DE TIMEOUT E FALLBACK
 * 
 * Testa se o sistema de fallback funciona corretamente em casos de timeout
 */

const https = require('https');

const DEAL_ID = '62719';
const BASE_URL = 'https://api-test.ggvinteligencia.com.br/webhook/diag-ggv-register';

// Fun√ß√£o para simular timeout
function makeRequestWithTimeout(url, options = {}, timeoutMs = 5000) {
    return new Promise((resolve, reject) => {
        const urlObj = new URL(url);
        
        const requestOptions = {
            hostname: urlObj.hostname,
            port: 443,
            path: urlObj.pathname + urlObj.search,
            method: options.method || 'GET',
            headers: {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
                'Accept': '*/*',
                'Content-Type': 'application/json',
                'Origin': 'https://app.grupoggv.com',
                'Referer': 'https://app.grupoggv.com/',
                ...options.headers
            },
            timeout: timeoutMs // Timeout espec√≠fico para teste
        };
        
        const req = https.request(requestOptions, (res) => {
            let data = '';
            res.on('data', (chunk) => data += chunk);
            res.on('end', () => {
                resolve({
                    status: res.statusCode,
                    statusText: res.statusMessage,
                    headers: res.headers,
                    body: data,
                    timedOut: false
                });
            });
        });
        
        req.on('error', (error) => {
            reject({ error: error.message, timedOut: false });
        });
        
        req.on('timeout', () => {
            req.destroy();
            reject({ error: 'Request timeout', timedOut: true });
        });
        
        if (options.body) {
            req.write(options.body);
        }
        
        req.end();
    });
}

// Teste 1: Timeout r√°pido (2 segundos) para for√ßar fallback
async function testTimeoutFallback() {
    console.log('üïê TESTE 1: TIMEOUT R√ÅPIDO (2s) - For√ßar fallback');
    console.log('=' .repeat(60));
    
    const payload = {
        action: 'update_deal_fields',
        deal_id: DEAL_ID,
        timestamp: new Date().toISOString(),
        
        companyData: {
            companyName: "Construtora Ikigai",
            email: "Grupokondo@gmail.com",
            activityBranch: "Servi√ßo",
            monthlyBilling: "Acima de R$ 1 milh√£o/m√™s",
            salesTeamSize: "De 1 a 3 colaboradores",
            dealId: DEAL_ID
        },
        
        clientContext: {
            situacao: "Teste de timeout - empresa em crescimento",
            problema: "Teste de timeout - necessidade de estrutura√ß√£o",
            perfil_do_cliente: "Teste de timeout - consultoria estabelecida"
        },
        
        source: 'timeout-test',
        version: 'timeout-test-v1'
    };
    
    console.log('üì¶ Payload size:', JSON.stringify(payload).length, 'bytes');
    console.log('‚è∞ Timeout configurado: 2 segundos (for√ßar timeout)');
    
    try {
        const startTime = Date.now();
        const response = await makeRequestWithTimeout(BASE_URL, {
            method: 'POST',
            headers: {
                'X-Request-Type': 'timeout-test',
                'X-Timeout': '2000'
            },
            body: JSON.stringify(payload)
        }, 2000); // 2 segundos apenas
        
        const duration = Date.now() - startTime;
        
        console.log(`üìä Status: ${response.status} ${response.statusText}`);
        console.log(`üìä Dura√ß√£o: ${duration}ms`);
        console.log(`üìä Body: ${response.body}`);
        console.log(`üìä Timeout?: ${response.timedOut ? 'SIM' : 'N√ÉO'}`);
        
        return { 
            success: response.status >= 200 && response.status < 300, 
            timedOut: response.timedOut,
            duration,
            status: response.status 
        };
        
    } catch (error) {
        const duration = Date.now() - startTime;
        console.log(`‚ùå ERRO: ${error.error}`);
        console.log(`‚è∞ Timeout?: ${error.timedOut ? 'SIM' : 'N√ÉO'}`);
        console.log(`üìä Dura√ß√£o: ${duration}ms`);
        
        return { 
            success: false, 
            timedOut: error.timedOut,
            duration,
            error: error.error 
        };
    }
}

// Teste 2: Timeout normal (15s) para compara√ß√£o
async function testNormalTimeout() {
    console.log('\nüïê TESTE 2: TIMEOUT NORMAL (15s) - Comportamento padr√£o');
    console.log('=' .repeat(60));
    
    const payload = {
        deal_id: DEAL_ID,
        timestamp: new Date().toISOString(),
        action: 'ai_analysis_completed',
        
        body: {
            results: {
                maturityPercentage: 75
            },
            resultUrl: `https://app.grupoggv.com/r/timeout-test-${DEAL_ID}-${Date.now()}`,
            deal_id: DEAL_ID,
            
            diagnosticAnswers: [
                {
                    questionId: 1,
                    question: "Teste de timeout - processo estruturado?",
                    answer: "Sim",
                    description: "Teste funcionando",
                    score: 10
                }
            ]
        },
        
        companyData: {
            companyName: "Construtora Ikigai",
            email: "Grupokondo@gmail.com",
            activityBranch: "Servi√ßo",
            monthlyBilling: "Acima de R$ 1 milh√£o/m√™s",
            salesTeamSize: "De 1 a 3 colaboradores"
        },
        
        clientContext: {
            situacao: "Teste de timeout normal - empresa em crescimento",
            problema: "Teste de timeout normal - necessidade de estrutura√ß√£o",
            perfil_do_cliente: "Teste de timeout normal - consultoria estabelecida"
        },
        
        segment: {
            name: "Geral",
            id: "gen_1"
        },
        
        source: "timeout-test",
        version: "timeout-normal-test"
    };
    
    console.log('üì¶ Payload size:', JSON.stringify(payload).length, 'bytes');
    console.log('‚è∞ Timeout configurado: 15 segundos (normal)');
    
    try {
        const startTime = Date.now();
        const response = await makeRequestWithTimeout(BASE_URL, {
            method: 'POST',
            headers: {
                'X-Request-Type': 'timeout-normal-test',
                'X-Timeout': '15000'
            },
            body: JSON.stringify(payload)
        }, 15000); // 15 segundos
        
        const duration = Date.now() - startTime;
        
        console.log(`üìä Status: ${response.status} ${response.statusText}`);
        console.log(`üìä Dura√ß√£o: ${duration}ms`);
        console.log(`üìä Body: ${response.body}`);
        console.log(`üìä Timeout?: ${response.timedOut ? 'SIM' : 'N√ÉO'}`);
        
        return { 
            success: response.status >= 200 && response.status < 300, 
            timedOut: response.timedOut,
            duration,
            status: response.status 
        };
        
    } catch (error) {
        const duration = Date.now() - startTime;
        console.log(`‚ùå ERRO: ${error.error}`);
        console.log(`‚è∞ Timeout?: ${error.timedOut ? 'SIM' : 'N√ÉO'}`);
        console.log(`üìä Dura√ß√£o: ${duration}ms`);
        
        return { 
            success: false, 
            timedOut: error.timedOut,
            duration,
            error: error.error 
        };
    }
}

// Teste 3: Simular comportamento do frontend com AbortController
async function testAbortController() {
    console.log('\nüïê TESTE 3: ABORT CONTROLLER - Simulando frontend');
    console.log('=' .repeat(60));
    
    const payload = {
        action: 'update_deal_fields',
        deal_id: DEAL_ID,
        timestamp: new Date().toISOString(),
        
        clientContext: {
            situacao: "Teste AbortController - empresa em crescimento",
            problema: "Teste AbortController - necessidade de estrutura√ß√£o",
            perfil_do_cliente: "Teste AbortController - consultoria estabelecida"
        },
        
        source: 'abort-controller-test',
        version: 'abort-test-v1'
    };
    
    console.log('üì¶ Testando comportamento do AbortController...');
    console.log('‚è∞ Timeout: 3 segundos (teste de abort)');
    
    try {
        const startTime = Date.now();
        
        // Simular AbortController como no c√≥digo real
        const controller = new (global.AbortController || require('abort-controller'))();
        const timeoutId = setTimeout(() => {
            console.log('‚è∞ AbortController - Cancelando requisi√ß√£o ap√≥s 3s');
            controller.abort();
        }, 3000);
        
        // Usar fetch com AbortController (se dispon√≠vel)
        let response;
        try {
            if (typeof fetch !== 'undefined') {
                response = await fetch(BASE_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Request-Type': 'abort-controller-test'
                    },
                    body: JSON.stringify(payload),
                    signal: controller.signal
                });
            } else {
                // Fallback para Node.js sem fetch
                response = await makeRequestWithTimeout(BASE_URL, {
                    method: 'POST',
                    headers: {
                        'X-Request-Type': 'abort-controller-test'
                    },
                    body: JSON.stringify(payload)
                }, 3000);
            }
            
            clearTimeout(timeoutId);
            const duration = Date.now() - startTime;
            
            console.log(`üìä Status: ${response.status}`);
            console.log(`üìä Dura√ß√£o: ${duration}ms`);
            console.log(`üìä Cancelado?: N√ÉO (completou antes do timeout)`);
            
            return { 
                success: response.status >= 200 && response.status < 300, 
                aborted: false,
                duration,
                status: response.status 
            };
            
        } catch (fetchError) {
            clearTimeout(timeoutId);
            const duration = Date.now() - startTime;
            
            const isAborted = fetchError.name === 'AbortError' || 
                            fetchError.message?.includes('abort') ||
                            fetchError.error?.includes('timeout');
            
            console.log(`‚ùå ERRO: ${fetchError.message || fetchError.error || fetchError}`);
            console.log(`üìä Dura√ß√£o: ${duration}ms`);
            console.log(`üìä Cancelado?: ${isAborted ? 'SIM' : 'N√ÉO'}`);
            
            return { 
                success: false, 
                aborted: isAborted,
                duration,
                error: fetchError.message || fetchError.error || fetchError 
            };
        }
        
    } catch (error) {
        console.log(`‚ùå ERRO GERAL: ${error.message || error}`);
        return { success: false, error: error.message || error };
    }
}

async function runTimeoutTests() {
    console.log('üïê TESTES DE TIMEOUT E FALLBACK\n');
    
    const results = {
        timeoutFallback: null,
        normalTimeout: null,
        abortController: null
    };
    
    // Teste 1: Timeout r√°pido
    results.timeoutFallback = await testTimeoutFallback();
    
    // Aguardar entre testes
    console.log('\n‚è≥ Aguardando 3 segundos...');
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // Teste 2: Timeout normal
    results.normalTimeout = await testNormalTimeout();
    
    // Aguardar entre testes
    console.log('\n‚è≥ Aguardando 3 segundos...');
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // Teste 3: AbortController
    results.abortController = await testAbortController();
    
    // Resumo
    console.log('\n' + '='.repeat(70));
    console.log('üìã RESUMO DOS TESTES DE TIMEOUT');
    console.log('='.repeat(70));
    
    console.log(`üïê Timeout R√°pido (2s): ${results.timeoutFallback?.success ? '‚úÖ' : '‚ùå'} ${results.timeoutFallback?.timedOut ? '(TIMEOUT)' : '(OK)'}`);
    console.log(`üïê Timeout Normal (15s): ${results.normalTimeout?.success ? '‚úÖ' : '‚ùå'} ${results.normalTimeout?.timedOut ? '(TIMEOUT)' : '(OK)'}`);
    console.log(`üïê AbortController (3s): ${results.abortController?.success ? '‚úÖ' : '‚ùå'} ${results.abortController?.aborted ? '(ABORTED)' : '(OK)'}`);
    
    console.log('\nüîç AN√ÅLISE:');
    
    if (results.normalTimeout?.success) {
        console.log('‚úÖ Sistema principal funcionando (diagn√≥stico OK)');
    }
    
    if (results.timeoutFallback?.timedOut || results.abortController?.aborted) {
        console.log('‚úÖ Sistema de timeout funcionando (detecta timeouts)');
        console.log('üìù Em caso de timeout no update fields, o fluxo continua');
        console.log('üìù O diagn√≥stico principal n√£o √© bloqueado por timeouts');
    }
    
    if (!results.timeoutFallback?.success && !results.abortController?.success) {
        console.log('‚úÖ Fallback funcionando (falhas n√£o bloqueiam o fluxo)');
    }
    
    console.log('\nüí° COMPORTAMENTO ESPERADO:');
    console.log('1. ‚è∞ Update fields pode dar timeout (n√£o cr√≠tico)');
    console.log('2. üéØ Diagn√≥stico principal deve sempre funcionar');
    console.log('3. üõ°Ô∏è Timeouts n√£o devem bloquear o fluxo principal');
    console.log('4. üîÑ Sistema continua funcionando mesmo com falhas parciais');
    
    // Salvar relat√≥rio
    const fs = require('fs');
    const report = {
        dealId: DEAL_ID,
        timestamp: new Date().toISOString(),
        testType: 'timeout-fallback-validation',
        results: results,
        conclusion: results.normalTimeout?.success ? 
            'SISTEMA DE TIMEOUT FUNCIONANDO - Fluxo principal OK' : 
            'NECESSITA INVESTIGA√á√ÉO - Fluxo principal com problema'
    };
    
    fs.writeFileSync(`timeout-fallback-report-${DEAL_ID}.json`, JSON.stringify(report, null, 2));
    console.log(`\nüìÑ Relat√≥rio salvo em: timeout-fallback-report-${DEAL_ID}.json`);
    
    return report;
}

if (require.main === module) {
    runTimeoutTests().catch(console.error);
}

module.exports = { runTimeoutTests, testTimeoutFallback, testNormalTimeout, testAbortController };
